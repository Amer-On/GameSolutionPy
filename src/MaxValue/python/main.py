def indent():
    print('\n')  # Отступ, чтобы не мешать всё в общую кашу


num = 1
adr_in = '../input/input' + str(num) + '.txt'
# Создаём переменную пути, где хранятся входные данные

fil = open(adr_in, 'r')
# Создаём переменную для считывания с файла

# Далее считываем данные из файла
rows, columns = map(int, fil.readline().split())  # Размер поля
field = [list(map(int, fil.readline().split())) for i in range(rows)]  # Считываем значения поля в двумерный массив


field_cost = [[0]*columns for i in range(rows)]  # Дублируем массив для дальнейших изменений,
# не затрагивая основное поле(!!!Обязательно!!!)
field_cost[0][0] = field[0][0]  # Присваивание значения начальной клетки

print("Проверка на правильность считывания массива (Вывод игрового поля)")
for row in field:
    print(' '.join(map(str, row)))


# Начинаем заполнять field_cost
for j in range(1, columns):
    field_cost[0][j] = field_cost[0][j-1] + field[0][j]
# Заполнили первый ряд

for i in range(1, rows):
    field_cost[i][0] = field_cost[i-1][0] + field[i][0]
# Заполнили первую колонну(столбец)

for i in range(1, rows):
    for j in range(1, columns):
        # Пробегаемся по всем остальным элементам
        if field_cost[i][j-1] >= field_cost[i-1][j]:
            field_cost[i][j] = field_cost[i][j-1] + field[i][j]
        else:
            field_cost[i][j] = field_cost[i-1][j] + field[i][j]
        # Сравниваем две позиции, откуда мы могли прийти(сверху/слева) и находим из них наибольшую
        # Присваиваем ячейке сумму ячейки, откуда мы пришли и собственного значения поля

# Мы создали ценовое поле, где указана максимальная цена, за которую можно дойти до координаты
indent()
print("Вывод ценового поля")
for row in field_cost:
    print(' '.join(map(str, row)))


# На данном этапе мы уже можем сказать, какой максимальной ценой можно добраться до конца
indent()
maximum = field_cost[rows-1][columns-1]
print("Максимальная цена: " + str(maximum))


# Далее нам надо найти путь, по которому достигается эта цена
moves = []  # Создаём пустой массив, в который мы будем складывать последовательность движения
row, column = rows - 1, columns - 1


# Запускаем цикл с конца поля, который остановится, как только мы дойдём до начала поля
while True:
    if row == 0 and column == 0:
        break  # Собственно выход из цикла на начальном поле

    if row > 0 and column > 0:  # Если мы не дошли до одного из краёв, то сравниваем как верх, так и лево
        # Сравниваем левую и верхнюю ячейки
        # Если верхняя больше, то сходим на ряд ниже
        if field_cost[row][column-1] <= field_cost[row-1][column] <= field_cost[row][column]:
            # Сравниваю с текущей позицией во избежание непредвиденных ошибок, что совсем не обязательно
            row -= 1
            moves.append("D")
        # Если же левая больше, то идём на один элемент вниз
        elif field_cost[row-1][column] <= field_cost[row][column-1] <= field_cost[row][column]:
            # Опять же можно просто сделать else, но во избежания непредвиденных ошибок
            # и для наглядности прописал полностью
            column -= 1
            moves.append("R")

    # Когда достигаем одного из краёв у нас уже остаётся только возможность двигаться
    # В одном направлении, поэтому этим мы и занимаемся
    else:
        if row == 0:
            column -= 1
            moves.append('R')
        elif column == 0:
            row -= 1
            moves.append('D')

moves = moves[::-1]  # Переворачиваем ход наших действий, ведь мы начинали с конца, а не с начала
print("Алгоритм ходов для достижения максимальной цены:")
print(' '.join(moves))

fil.close()
